using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Airplane 클래스와 관련된 이벤트를 위해 존재
/// </summary>
/// <param name="myInfo"> 해당 Airplane(this)의 정보를 argument로 전달함. </param>
public delegate void AirplaneEvent(Airplane myInfo);

[RequireComponent(typeof(Rigidbody))]
[RequireComponent(typeof(Collider))]
// 이거 abstract 클래스로 지정하자.
public class Airplane : Vehicle
{
    [SerializeField]
    private float _maxEnginePower = 40f;        // The maximum output of the engine.

    [SerializeField]
    private float _lift = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.

    [SerializeField]
    private float _zeroLiftSpeed = 300;         // The speed at which lift is no longer applied.

    [SerializeField]
    private float _pitchEffect = 1f;            // The strength of effect for pitch input.

    [SerializeField]
    private float _aerodynamicEffect = 0.02f;   // How much aerodynamics affect the speed of the aeroplane.

    [SerializeField]
    private float _airBrakesEffect = 3f;        // How much the air brakes effect the drag.

    [SerializeField]
    private float _throttleChangeSpeed = 0.3f;  // The speed with which the throttle changes.

    [SerializeField]
    private float _dragIncreaseFactor = 0.001f; // how much drag should increase with speed.

    [SerializeField]
    private float _torqueFactor = 0.1f;

    [SerializeField] private float _currentForwardSpeed = 0.0f;

    public float Throttle { get; private set; }                     // The amount of throttle being used.
    public bool IsOnAirBrakes { get; private set; }                     // Whether or not the air brakes are being applied.
    public float ForwardSpeed { get; private set; }                 // How fast the aeroplane is traveling in it's forward direction.
    public float EnginePower { get; private set; }                  // How much power the engine is being given.
    public float MaxEnginePower { get { return _maxEnginePower; } }    // The maximum output of the engine.

    public float PitchAngle { get; private set; }
    public float PitchInput { get; private set; }
    public float ThrottleInput { get; private set; }

    private float _OriginalDrag;         // The drag when the scene starts.
    private float _OriginalAngularDrag;  // The angular drag when the scene starts.
    private float _AeroFactor;

    private Rigidbody _rigidbody;

    public float liftPower = 0f;
    public float minEnginePower = 50f;

    // altitude1 -> 출력이 줄어들기 시작하는 고도
    // altitude2 -> 출력이 minimum에 도달하는 고도
    public float altitudePhase1Start = 0f;
    public float altitudePhase2Start = 0f;

    [Header("Smoke")]
    public float graySmokeHP;
    public float blackSmokeHP;
    [SerializeField]
    private ParticleSystem graySmokeParticle;
    [SerializeField]
    private ParticleSystem blackSmokeParticle;

    public event AirplaneEvent onCrashedEvent = delegate { };


    private void Start()
    {
        _rigidbody = GetComponent<Rigidbody>();
        // Store original drag settings, these are modified during flight.
        _OriginalDrag = _rigidbody.drag;
        _OriginalAngularDrag = _rigidbody.angularDrag;

        Vector3 currentVelo = _rigidbody.velocity;
        currentVelo.z = 150;

        _rigidbody.velocity = currentVelo;
    }

    public void Move(float pitchInput, float throttleInput, bool airBrakes)
    {

        PitchInput = pitchInput;

        ThrottleInput = 1;
        IsOnAirBrakes = airBrakes;

        ClampInputs();

        CalculateRollAndPitchAngles();

        CalculateForwardSpeed();

        ControlThrottle();

        CalculateDrag();

        CaluclateAerodynamicEffect();

        CalculateLinearForces();

        CalculateTorque();

        _currentForwardSpeed = _rigidbody.velocity.x;
    }


    private void ClampInputs()
    {
        // clamp the inputs to -1 to 1 range
        PitchInput = Mathf.Clamp(PitchInput, -1, 1);

        ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
    }


    private void CalculateRollAndPitchAngles()
    {
        // Calculate roll & pitch angles
        // Calculate the flat forward direction (with no y component).
        var flatForward = transform.forward;
        flatForward.y = 0;
        // If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
        if (flatForward.sqrMagnitude > 0)
        {
            flatForward.Normalize();
            // calculate current pitch angle
            var localFlatForward = transform.InverseTransformDirection(flatForward);
            PitchAngle = Mathf.Atan2(localFlatForward.y, localFlatForward.z);

            // Roll Angle은 생략함.
        }
    }


    private void CalculateForwardSpeed()
    {
        // Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
        var localVelocity = transform.InverseTransformDirection(_rigidbody.velocity);
        ForwardSpeed = Mathf.Max(0, Mathf.Abs(localVelocity.z));
    }


    private void ControlThrottle()
    {
        // Adjust throttle based on throttle input (or immobilized state)
        Throttle = Mathf.Clamp01(Throttle + ThrottleInput * Time.deltaTime * _throttleChangeSpeed);

        // current engine power is just:
        EnginePower = Throttle * _maxEnginePower * CalculateEngineEfficiency();
    }


    private void CalculateDrag()
    {
        // increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough
        float extraDrag = _rigidbody.velocity.magnitude * _dragIncreaseFactor;
        // Air brakes work by directly modifying drag. This part is actually pretty realistic!
        _rigidbody.drag = (IsOnAirBrakes ? (_OriginalDrag + extraDrag) * _airBrakesEffect : _OriginalDrag + extraDrag);
        // Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin
        _rigidbody.angularDrag = _OriginalAngularDrag * ForwardSpeed;
    }


    private void CaluclateAerodynamicEffect()
    {
        // "Aerodynamic" calculations. This is a very simple approximation of the effect that a plane
        // will naturally try to align itself in the direction that it's facing when moving at speed.
        // Without this, the plane would behave a bit like the asteroids spaceship!
        if (_rigidbody.velocity.magnitude > 0)
        {
            // compare the direction we're pointing with the direction we're moving:
            _AeroFactor = Vector3.Dot(transform.forward, _rigidbody.velocity.normalized);
            // multipled by itself results in a desirable rolloff curve of the effect
            _AeroFactor *= _AeroFactor;
            // Finally we calculate a new velocity by bending the current velocity direction towards
            // the the direction the plane is facing, by an amount based on this aeroFactor
            var newVelocity = Vector3.Lerp(_rigidbody.velocity, transform.forward * ForwardSpeed,
                                           _AeroFactor * ForwardSpeed * _aerodynamicEffect * Time.deltaTime);
            _rigidbody.velocity = newVelocity;
            // Debug.Log("LerpValue: " + _AeroFactor * ForwardSpeed * _aerodynamicEffect * Time.deltaTime);
            // Debug.Log("DeltaTime: " + Time.deltaTime);

            // also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up
            // pointing downwards in a stall
            //_rigidbody.rotation = Quaternion.Slerp(Quaternion.Euler(transform.localRotation.x, 0, _rigidbody.rotation),
            //                                      Quaternion.LookRotation(_rigidbody.velocity, transform.up),
            //                                      _aerodynamicEffect * Time.deltaTime).eulerAngles.z;
            _rigidbody.rotation = Quaternion.Slerp(_rigidbody.rotation,
                                                      Quaternion.LookRotation(_rigidbody.velocity, transform.up),
                                                      _aerodynamicEffect * Time.deltaTime);
        }
    }


    private void CalculateLinearForces()
    {
        // Now calculate forces acting on the aeroplane:
        // we accumulate forces into this variable:
        var forces = Vector3.zero;
        // Add the engine power in the forward direction
        forces += EnginePower * transform.forward;
        // The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
        var liftDirection = Vector3.Cross(_rigidbody.velocity, transform.right).normalized;
        // The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
        // shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
        // a simple way of doing it automatically:
        var zeroLiftFactor = Mathf.InverseLerp(_zeroLiftSpeed, 0, ForwardSpeed);
        // Calculate and add the lift power
        var liftPower = ForwardSpeed * ForwardSpeed * _lift * zeroLiftFactor * _AeroFactor;
        this.liftPower = liftPower;
        forces += liftPower * liftDirection;
        // Apply the calculated forces to the the Rigidbody
        _rigidbody.AddForce(forces);
    }


    private void CalculateTorque()
    {
        var torque = Vector3.zero;
        torque = PitchInput * _pitchEffect * transform.right;

        _rigidbody.AddTorque(torque * ForwardSpeed * _AeroFactor * _torqueFactor);
    }

    private float CalculateEngineEfficiency()
    {
        float currentAltitude = transform.localPosition.y;
        float engineEfficiency = 1f;


        // 엔진 출력이 저하하기 시작하는 고도에 도달했으면
        if (altitudePhase1Start < currentAltitude)
        {
            engineEfficiency = Mathf.Lerp(altitudePhase1Start, altitudePhase2Start, currentAltitude);
        }

        return engineEfficiency;
    }

    protected override void OnDamaged(float damage)
    {
        if (HP <= blackSmokeHP)
        {
            graySmokeParticle.Stop();
            blackSmokeParticle.Play();
        }
        else if (HP <= graySmokeHP)
        {
            graySmokeParticle.Play();
            blackSmokeParticle.Stop();
        }
    }

    protected override void OnHealed(float healPoint)
    {
        if (HP >= blackSmokeHP)
        {
            blackSmokeParticle.Stop();
        }
        if (HP >= graySmokeHP)
        {
            graySmokeParticle.Stop();
        }
    }

    protected virtual void OnCrashed()
    {
        onCrashedEvent(this);

        this.VoxDestroy();
    }

    protected override void OnActivateObject()
    {
        controller.enabled = true;
        Collider collider = gameObject.GetComponent<Collider>();
        if (collider)
        {
            collider.enabled = true;
        }

        _rigidbody.isKinematic = false;

        base.OnActivateObject();
    }

    protected override void OnUnActivateObject()
    {
        controller.enabled = false;
        Collider collider = gameObject.GetComponent<Collider>();
        if (collider)
        {
            collider.enabled = false;
        }

        _rigidbody.isKinematic = true;

        base.OnUnActivateObject();
    }

    

    // 지상충돌 및 오브젝트 사이의 충돌 감지
    // 해당 스크립트가 너무 무거워지는 감이 있지만, 여기가 적소라고 판단했음.
    protected virtual void OnCollisionEnter(Collision collision)
    {
        // Enemy끼리, Enemy와 Wall 사이도 충돌이 일어나도록 함.
        if (collision.collider.CompareTag("Player") ||
            collision.collider.CompareTag("Enemy") ||
            collision.collider.CompareTag("Wall"))
        {

            OnCrashed();

        }
    }
}
